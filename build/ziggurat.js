// Generated by CoffeeScript 2.7.0
  // contains all core logic (templates) as well as query
  // note: requires imperative HTML to work
var create_math_function, fun, j, key, len, ref, zg,
  indexOf = [].indexOf;

if (typeof HTML === "undefined" || HTML === null) {
  throw new Error("can't find HTML. did you forget to import imperative-html?");
}

zg = {};

// functions

// query
zg.query = function(selector) {
  var result;
  result = document.querySelectorAll(selector);
  if (result.length === 1) {
    return result[0];
  } else {
    return result;
  }
};

zg.queryone = function(selector) {
  return document.querySelector(selector);
};

zg.queryall = function(selector) {
  return document.querySelectorAll(selector);
};

// misc
zg.deepfind = function(data, path) {
  var index, j, len, node, ref;
  path = path.trim();
  ref = (function() {
    var l, len, ref, results;
    ref = path.split('.');
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      node = ref[l];
      if (node !== "") {
        results.push(node);
      }
    }
    return results;
  })();
  for (j = 0, len = ref.length; j < len; j++) {
    index = ref[j];
    data = data[index];
    if (data == null) {
      throw new Error(`'${path}' not in data '${data}'`);
    }
  }
  return data;
};

zg.evalwith = function(script, value) {
  return (function() {
    return eval(script);
  }).call(value);
};

Object.prototype.minus = function(...keys) {
  var k;
  return Object.fromEntries([
    (function() {
      var j,
    len,
    ref,
    results;
      ref = this;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        k = ref[j];
        results.push([k,
    this[k]]);
      }
      return results;
    }).call(this)
  ].filter(function(e) {
    return indexOf.call(keys, e) < 0;
  }));
};

Object.prototype.plus = function(other) {
  return Object.assign({}, this, other);
};

zg.VERSION = "0.9";

zg._INIT_LIST = [];

zg.init = function() {
  var f, j, len, ref;
  ref = zg._INIT_LIST;
  for (j = 0, len = ref.length; j < len; j++) {
    f = ref[j];
    f();
  }
  return console.log(`%cZiggurat ${zg.VERSION} initialized.`, "color: orange; font-weight: bold");
};

zg.formdata = function(element) {
  var data;
  data = {
    _keys_: [],
    toObject: function() {
      var k;
      return Object.fromEntries((function() {
        var j, len, ref, results;
        ref = this._keys_;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          k = ref[j];
          results.push([k, this[k]]);
        }
        return results;
      }).call(this));
    }
  };
  // for each entry in the form,
  // add a reference to it in data
  (new FormData(element)).forEach(function(_, k) {
    data._keys_.push(k);
    return Object.defineProperty(data, k, {
      get: function() {
        return element[k].value;
      },
      set: function(v) {
        return element[k].value = v;
      }
    });
  });
  return data;
};

zg._INIT_LIST.push(function() {
  var element, fn_name, j, len, ref, results;
  ref = zg.queryall('form[zg-submit]');
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    element = ref[j];
    fn_name = element.getAttribute("zg-submit");
    results.push(element.onsubmit = function(event) {
      var e;
      try {
        
        // fuck around and find out
        window[fn_name](zg.formdata(element));
      } catch (error) {
        e = error;
        console.error(e);
      }
      
      // prevent event default
      event.preventDefault;
      return false;
    });
  }
  return results;
});

zg.mirror = class {
  constructor(name1, value, setters, options) {
    this.name = name1;
    if (zg.MIRROR_INDEX[this.name] != null) {
      throw `can't create mirror ${this.name}; it already exists`;
    }
    console.log(`making mirror ${this.name}`);
    zg.MIRROR_INDEX[this.name] = this;
    Object.defineProperty(this, "v", {
      get: function() {
        return this._value_;
      },
      set: function(val) {
        // when V is set, also update the bound value in HTML
        this._value_ = val;
        return this.update();
      }
    });
    
    // also call the setter
    this.setters = setters || [];
    this.options = options;
    if (value != null) {
      this.v = value;
    }
  }

  update() {
    var j, len, ref, results, setter;
    ref = this.setters;
    // call custom setters
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      setter = ref[j];
      results.push(setter(this._value_, this.name, this.options));
    }
    return results;
  }

};

zg.mirror_to_document = function(value, name) {
  var bind, j, l, len, len1, ref, ref1, result, results, script, show, toggle;
  ref = zg.queryall(`*[zg-bind-to=${name}], *[zg-sync-with=${name}]`);
  // update BINDs
  for (j = 0, len = ref.length; j < len; j++) {
    bind = ref[j];
    script = bind.getAttribute("zg-script");
    result = script != null ? zg.evalwith(script, value) : value;
    if (bind.nodeName === "INPUT") {
      bind.value = result;
    } else {
      bind.innerText = result;
    }
  }
  ref1 = zg.queryall(`zg-when[name=${name}]`);
  
  // update WHENs 
  results = [];
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    toggle = ref1[l];
    show = false;
    script = toggle.getAttribute('zg-script');
    if (script != null) {
      show = zg.evalwith(script, value);
    }
    results.push(toggle.hidden = !show);
  }
  return results;
};

zg.mirror_to_localstorage = function(value, name) {
  return localStorage[name] = value;
};

zg.mirror_to_console = function(value, name) {
  return console.debug(`ziggurat: mirror ${name} = ${value}`);
};

zg.MIRROR_INDEX = {};

zg._INIT_LIST.push(function() {
  var element, handle_syncs, j, len, ref, results;
  handle_syncs = function() {
    var mirror, mirror_name;
    mirror_name = this.getAttribute('zg-sync-with');
    mirror = zg.MIRROR_INDEX[mirror_name];
    if (mirror == null) {
      throw `mirror ${mirror_name} doesn't exist!`;
    }
    return mirror.v = this.value; // trigger setters (hopefully dont cause an endlessly recursive loop of event handlers)
  };
  ref = zg.queryall("*[zg-sync-with]");
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    element = ref[j];
    element.addEventListener("oninput", handle_syncs);
    results.push(element.addEventListener("onchange", handle_syncs));
  }
  return results;
});

zg.cookies = new Proxy({}, {
  get: function(_, name) {
    var cookie, cookies, j, len;
    // extract cookie from document.cookie
    cookies = (function() {
      var j, len, ref, results;
      ref = document.cookie.split('; ');
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cookie = ref[j];
        results.push(cookie.split('='));
      }
      return results;
    })();
    for (j = 0, len = cookies.length; j < len; j++) {
      cookie = cookies[j];
      if (cookie[0] === name) {
        return cookie[1];
      }
    }
  },
  set: function(_, name, value) {
    var cookie, k, v;
    // build a statement to be put into document.cookie
    if (typeof value === 'object') {
      cookie = `${name}=${value.value}; `;
      // add every property to cookie string
      cookie += ((function() {
        var results;
        if (k !== 'value') {
          results = [];
          for (k in value) {
            v = value[k];
            results.push(v != null ? `${k} = ${v}` : `${k}`);
          }
          return results;
        }
      })()).join('; ');
    } else {
      cookie = `${name}=${value}`;
    }
    return document.cookie = cookie;
  }
});

zg.load_json_cookie = function(name) {
  var SyntaxError, val;
  val = zg.cookies[name];
  try {
    return JSON.parse(val);
  } catch (error) {
    SyntaxError = error;
    return null;
  }
};

zg.mirror_to_cookie = function(value, name, options) {
  return zg.cookies[name] = {
    "value": JSON.stringify(value),
    ...options
  };
};

Number.prototype.nanos = function() {
  return this.micros() / 1000;
};

Number.prototype.micros = function() {
  return this.millis() / 1000;
};

Number.prototype.millis = function() {
  return this.seconds() / 1000;
};

Number.prototype.seconds = function() {
  return this;
};

Number.prototype.minutes = function() {
  return this.seconds() * 60;
};

Number.prototype.hours = function() {
  return this.minutes() * 60;
};

Number.prototype.days = function() {
  return this.hours() * 24;
};

Number.prototype.months = function() {
  return this.days() * 30.43684914;
};

Number.prototype.years = function() {
  return this.months() * 12;
};

Number.prototype.ago = function() {
  return new Date(Date.now() - this * 1000);
};

Number.prototype.fromnow = function() {
  return new Date(Date.now() + this * 1000);
};

create_math_function = function(name) {
  return function() {
    return this(Math[name]);
  };
};

ref = Object.getOwnPropertyNames(Math);
for (j = 0, len = ref.length; j < len; j++) {
  key = ref[j];
  fun = Math[key];
  if (fun.length === 1 && typeof fun === "function") {
    eval(`Number.prototype.${key} = function() {return Math.${key}(this)}`);
  }
}

zg.stream = {};

zg.HttpException = class HttpException extends Error {
  constructor(status) {
    super(`Recieved code ${status} from server`);
    this.status = status;
  }

};

// chunked fetch
// yields all data available
zg.stream.text = async function*(url, options) {
  var data, decoder, reader, res, result;
  res = (await fetch(url, options));
  if (!res.ok) {
    throw new zg.HttpException(res.statusCode);
  }
  reader = res.body.getReader();
  decoder = new TextDecoder();
  while (true) {
    result = (await reader.read());
    data = decoder.decode(result.value);
    if (data.length > 0) {
      yield data;
    }
    if (result.done) {
      return;
    }
  }
};

// yields all lines as raw text
zg.stream.lines = async function*(url, options) {
  var buffer, data, l, len1, line, lines, ref1, results;
  buffer = "";
  ref1 = zg.stream.text(url, options);
  for await (data of ref1) {
    buffer += data;
    lines = buffer.split("\n");
    if (lines.length > 1) {
      yield lines[0];
      lines = lines.slice(1);
      buffer = lines.join("\n");
    }
  }
  results = [];
  for (l = 0, len1 = lines.length; l < len1; l++) {
    line = lines[l];
    if (line.length > 0) {
      results.push((yield line));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

// yields all lines as JSON
zg.stream.jsonl = async function*(url, options) {
  var line, ref1, results;
  ref1 = zg.stream.lines(url, options);
  results = [];
  for await (line of ref1) {
    try {
      results.push((yield JSON.parse(line)));
    } catch (error) {}
  }
  return results;
};

// template creation
zg.create = function(name, data) {
  var build, template;
  template = zg.queryone("zg-template#" + name);
  if (template == null) {
    throw new TypeError('no such template with name ' + name);
  }
  build = function(div, data) {
    var element, elements, i, l, len1, m, new_elements, ref1, ref2, replace_vars;
    elements = div.cloneNode(true);
    new_elements = [];
    ref1 = elements.childNodes;
    // compile every child
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      element = ref1[l];
      replace_vars = function(text) {
        return text.replace(/\\?\$\{(.+?)\}/g, function(match, script) {
          if (match.startsWith('\\')) {
            return match;
          } else {
            return zg.evalwith(script, data);
          }
        });
      };
      
          // depending on tag, replace with something
      switch (element.nodeName.toLowerCase()) {
        case "zg-if":
          if (!(zg.evalwith(element.getAttribute("zg-script"), data))) {
            element = document.createTextNode("");
          }
      }
      if (element.nodeName === '#text') {
        element.data = replace_vars(element.data);
      } else {
        for (i = m = 0, ref2 = element.attributes.length; (0 <= ref2 ? m < ref2 : m > ref2); i = 0 <= ref2 ? ++m : --m) {
          element.attributes[i] = replace_vars(element.attributes[i].value);
        }
      }
      
      // if the child has more children, build the child
      if (element.children != null) {
        element.replaceChildren(...(build(element, data)));
      }
      new_elements.push(element);
    }
    return new_elements;
  };
  return HTML.div(build(template, data));
};

zg.multimirror = class {
  push(data) {
    var bind, l, len1, ref1;
    this.v.push(data);
    ref1 = zg.queryall(`zg-multibind[name=${this.name}]`);
    
    // update ZG-MULTIBINDs
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      bind = ref1[l];
      bind.appendChild(zg.create(this.template, data));
    }
    return data;
  }

  insert(element, index) {
    var bind, l, len1, ref1;
    this.v.splice(index, 0, element);
    if (index === -1) {
      this.push(element);
    }
    ref1 = zg.queryall(`zg-multibind[name=${this.name}]`);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      bind = ref1[l];
      bind.appendBefore(bind.children[index], zg.create(this.template, element));
    }
    return element;
  }

  delete(index) {
    var bind, l, len1, ref1, results;
    // remove Nth child
    if (index < 0) {
      this.v.length - -index;
    } else {
      index;
    }
    if (index < this.v.length) {
      this.v.splice(index, 1);
      ref1 = zg.queryall(`zg-multibind[name=${this.name}]`);
      results = [];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        bind = ref1[l];
        results.push(bind.removeChild(bind.children[index]));
      }
      return results;
    }
  }

  clear() {
    var bind, l, len1, ref1, results;
    this.v = [];
    ref1 = zg.queryall(`zg-multibind[name=${this.name}]`);
    results = [];
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      bind = ref1[l];
      results.push(bind.innerHTML = "");
    }
    return results;
  }

  pop() {
    return delete -1;
  }

  constructor(name1, template1, _value) {
    var e, l, len1;
    this.name = name1;
    this.template = template1;
    this.v = [];
    if (_value != null) {
      for (l = 0, len1 = _value.length; l < len1; l++) {
        e = _value[l];
        this.push(e);
      }
    }
  }

};
