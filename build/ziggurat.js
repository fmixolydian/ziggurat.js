// Generated by CoffeeScript 2.7.0
// contains all core logic (templates) as well as query
// note: requires imperative HTML to work
var zg;

if (typeof HTML === "undefined" || HTML === null) {
  throw new Error("can't find HTML. did you forget to import imperative-html?");
}

zg = {};

// functions

// query
zg.query = function(selector) {
  var result;
  result = document.querySelectorAll(selector);
  if (result.length === 1) {
    return result[0];
  } else {
    return result;
  }
};

zg.queryone = function(selector) {
  return document.querySelector(selector);
};

zg.queryall = function(selector) {
  return document.querySelectorAll(selector);
};

// misc
zg.deepfind = function(data, path) {
  var i, index, len, node, ref;
  path = path.trim();
  ref = (function() {
    var j, len, ref, results;
    ref = path.split('.');
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      if (node !== "") {
        results.push(node);
      }
    }
    return results;
  })();
  for (i = 0, len = ref.length; i < len; i++) {
    index = ref[i];
    data = data[index];
    if (data == null) {
      throw new Error(`'${path}' not in data '${data}'`);
    }
  }
  return data;
};
// Generated by CoffeeScript 2.7.0
var element, fn_name, i, len, ref;

zg.formdata = function(element) {
  var data;
  data = {};
  // for each entry in the form,
  // add a reference to it in data
  (new FormData(element)).forEach(function(_, k) {
    return Object.defineProperty(data, k, {
      get: function() {
        return element[k].value;
      },
      set: function(v) {
        return element[k].value = v;
      }
    });
  });
  return data;
};

ref = zg.queryall('form[zg-submit]');
for (i = 0, len = ref.length; i < len; i++) {
  element = ref[i];
  fn_name = element.getAttribute("zg-submit");
  element.onsubmit = function(event) {
    var e;
    try {
      
      // fuck around and find out
      window[fn_name](zg.formdata(element));
    } catch (error) {
      e = error;
      console.error(e);
    }
    
    // prevent event default
    event.preventDefault;
    return false;
  };
}
// Generated by CoffeeScript 2.7.0
zg.mirror = class {
  constructor(name1, _value, setters, options) {
    this.name = name1;
    Object.defineProperty(this, "v", {
      get: function() {
        return this._value;
      },
      set: function(val) {
        var bind, i, j, len, len1, ref, results, setter;
        // when V is set, also update the bound valus in HTML
        this._value = val;
        ref = zg.queryall(`zg-bind[name=${this.name}]`);
        
        // update DOM
        for (i = 0, len = ref.length; i < len; i++) {
          bind = ref[i];
          bind.innerText = this._value;
        }

        // call custom setters
        results = [];
        for (j = 0, len1 = setters.length; j < len1; j++) {
          setter = setters[j];
          results.push(setter(this._value, this.name, options));
        }
        return results;
      }
    });
    
    // also call the setter
    this.v = _value;
  }

};

zg.mirror_to_localstorage = function(value, name, options) {
  return localStorage[name] = value;
};
// Generated by CoffeeScript 2.7.0
zg.cookies = new Proxy({}, {
  get: function(_, name) {
    var cookie, cookies, i, len;
    // extract cookie from document.cookie
    cookies = (function() {
      var i, len, ref, results;
      ref = document.cookie.split('; ');
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        cookie = ref[i];
        results.push(cookie.split('='));
      }
      return results;
    })();
    for (i = 0, len = cookies.length; i < len; i++) {
      cookie = cookies[i];
      if (cookie[0] === name) {
        return cookie[1];
      }
    }
  },
  set: function(_, name, value) {
    var cookie, k, v;
    // build a statement to be put into document.cookie
    if (typeof value === 'object') {
      cookie = `${name}=${value.value}; `;
      // add every property to cookie string
      cookie += ((function() {
        var results;
        if (k !== 'value') {
          results = [];
          for (k in value) {
            v = value[k];
            results.push(v != null ? `${k} = ${v}` : `${k}`);
          }
          return results;
        }
      })()).join('; ');
    } else {
      cookie = `${name}=${value}`;
    }
    return document.cookie = cookie;
  }
});

zg.mirror_to_cookie = function(value, name, options) {
  return zg.cookies[name] = {
    "value": JSON.stringify(value),
    ...options
  };
};
// Generated by CoffeeScript 2.7.0
// template creation
zg.create = function(name, data) {
  var build, template;
  template = zg.queryone("zg-template#" + name);
  if (template == null) {
    throw new TypeError('no such template with name ' + name);
  }
  build = function(div, data) {
    var child, elements, i, len, new_elements, ref;
    elements = div.cloneNode(true);
    new_elements = [];
    ref = elements.childNodes;
    // compile every child
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      // depending on tag, replace with something
      switch (child.nodeName.toLowerCase()) {
        case "zg-var":
          child = document.createTextNode(zg.deepfind(data, child.innerHTML));
      }
      // if the child has more children, build the child
      if (child.children != null) {
        child.replaceChildren(...(build(child, data)));
      }
      new_elements.push(child);
    }
    return new_elements;
  };
  return HTML.div(build(template, data));
};
// Generated by CoffeeScript 2.7.0
zg.stream = {};

zg.HttpException = class HttpException extends Error {
  constructor(status) {
    super(`Recieved code ${status} from server`);
    this.status = status;
  }

};

// chunked fetch
// yields all data available
zg.stream.text = async function*(url, options) {
  var data, decoder, reader, res, result;
  res = (await fetch(url, options));
  if (!res.ok) {
    throw new zg.HttpException(res.statusCode);
  }
  reader = res.body.getReader();
  decoder = new TextDecoder();
  while (true) {
    result = (await reader.read());
    data = decoder.decode(result.value);
    if (data.length > 0) {
      yield data;
    }
    if (result.done) {
      return;
    }
  }
};

// yields all lines as raw text
zg.stream.lines = async function*(url, options) {
  var buffer, data, i, len, line, lines, ref, results;
  buffer = "";
  ref = zg.stream.text(url, options);
  for await (data of ref) {
    buffer += data;
    lines = buffer.split("\n");
    if (lines.length > 1) {
      yield lines[0];
      lines = lines.slice(1);
      buffer = lines.join("\n");
    }
  }
  results = [];
  for (i = 0, len = lines.length; i < len; i++) {
    line = lines[i];
    if (line.length > 0) {
      results.push((yield line));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

// yields all lines as JSON
zg.stream.jsonl = async function*(url, options) {
  var line, ref, results;
  ref = zg.stream.lines(url, options);
  results = [];
  for await (line of ref) {
    try {
      results.push((yield JSON.parse(line)));
    } catch (error) {}
  }
  return results;
};
